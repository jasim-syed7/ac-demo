### Detailed Explanation of Day 13: Joins – Outer Joins

**Objective**: Master the use of outer joins (`LEFT`, `RIGHT`, and `FULL OUTER JOIN`) in Microsoft SQL Server (MSSQL) to combine data from multiple tables, including rows that don’t have matches. By the end of Day 13, you’ll understand the differences between `LEFT`, `RIGHT`, and `FULL OUTER JOIN`, how to handle NULL values in join results, and how outer joins compare to `INNER JOIN`. You’ll also practice combining tables to retrieve meaningful data in real-world scenarios. This day builds on your Days 1-12 skills, particularly `INNER JOIN`, table relationships, and other SQL clauses, enabling you to work with incomplete or unmatched data effectively.

**Duration**: 4-6 hours (split into theory, hands-on practice, and review). Adjust based on your comfort with SQL Server Management Studio (SSMS) and SQL syntax.

---

### Sub-Syllabus Breakdown
1. **LEFT, RIGHT, FULL OUTER JOIN** (1.5-2 hours)
   - Learn the syntax and behavior of `LEFT`, `RIGHT`, and `FULL OUTER JOIN`.
   - Understand how each join type handles unmatched rows.
2. **Handling NULLs** (1-1.5 hours)
   - Manage NULL values in outer join results using functions like `COALESCE` or `ISNULL`.
   - Explore scenarios where NULLs represent unmatched data.
3. **Compare with INNER JOIN** (1.5-2 hours)
   - Understand the differences between outer joins and `INNER JOIN`.
   - Practice 10-20 queries to combine 2-3 tables and compare join types in real-world scenarios.

---

### Step-by-Step Detailed Plan for Day 13

#### 1. LEFT, RIGHT, FULL OUTER JOIN (1.5-2 hours)
**Goal**: Master the syntax and use of `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, and `FULL OUTER JOIN` to retrieve data, including unmatched rows from one or both tables.

**Theory (45-60 minutes)**:
- **What are Outer Joins?**
  - Outer joins combine rows from two or more tables, including rows that don’t have matches in the other table(s), unlike `INNER JOIN` which only includes matched rows.
  - Three types:
    - **LEFT OUTER JOIN**: Returns all rows from the left table and matching rows from the right table; non-matching rows from the right table return NULLs.
    - **RIGHT OUTER JOIN**: Returns all rows from the right table and matching rows from the left table; non-matching rows from the left table return NULLs.
    - **FULL OUTER JOIN**: Returns all rows from both tables; non-matching rows from either table return NULLs for the other table’s columns.
  - Used when you need to include unmatched data (e.g., employees without departments, orders without transactions).
- **Syntax**:
  - **LEFT OUTER JOIN**:
    ```sql
    SELECT Columns
    FROM Table1
    LEFT OUTER JOIN Table2
    ON Table1.Column = Table2.Column;
    ```
    - Example:
      ```sql
      SELECT e.FirstName, e.LastName, d.DepartmentName
      FROM HR.Employees AS e
      LEFT OUTER JOIN HR.Departments AS d
      ON e.DepartmentID = d.DepartmentID;
      ```
      - Includes all employees, with NULL for `DepartmentName` if no matching department.
  - **RIGHT OUTER JOIN**:
    ```sql
    SELECT Columns
    FROM Table1
    RIGHT OUTER JOIN Table2
    ON Table1.Column = Table2.Column;
    ```
    - Example:
      ```sql
      SELECT e.FirstName, e.LastName, d.DepartmentName
      FROM HR.Employees AS e
      RIGHT OUTER JOIN HR.Departments AS d
      ON e.DepartmentID = d.DepartmentID;
      ```
      - Includes all departments, with NULL for employee details if no employees are assigned.
  - **FULL OUTER JOIN**:
    ```sql
    SELECT Columns
    FROM Table1
    FULL OUTER JOIN Table2
    ON Table1.Column = Table2.Column;
    ```
    - Example:
      ```sql
      SELECT e.FirstName, e.LastName, d.DepartmentName
      FROM HR.Employees AS e
      FULL OUTER JOIN HR.Departments AS d
      ON e.DepartmentID = d.DepartmentID;
      ```
      - Includes all employees and departments, with NULLs for unmatched rows.
- **Key Points**:
  - The keyword `OUTER` is optional (e.g., `LEFT JOIN` is equivalent to `LEFT OUTER JOIN`).
  - Use table aliases (e.g., `e` for `Employees`) for readability.
  - Outer joins are essential for reporting scenarios where you need all records from one or both tables (e.g., listing all customers, even those without orders).
  - Combine with `WHERE`, `GROUP BY`, `ORDER BY`, or functions for complex queries.
- **Best Practices**:
  - Choose the join type based on which table’s rows you need to preserve (`LEFT` for left table, `RIGHT` for right table, `FULL` for both).
  - Use clear aliases and qualify column names (e.g., `e.FirstName`) to avoid ambiguity.
  - Test joins on small datasets to verify included rows and NULLs.
  - Ensure foreign key constraints exist to maintain data integrity.
- **Common Pitfalls**:
  - Misinterpreting which table is “left” or “right” in the query.
  - Ambiguous column names in `SELECT` or `ON` clauses.
  - Performance issues with large tables (use indexes, covered later).
  - Overusing `FULL OUTER JOIN` (rarely needed; `LEFT` or `RIGHT` often suffice).
- **SSMS Tools**:
  - View results: Results pane shows joined rows with NULLs for unmatched data.
  - Debug errors: Messages pane shows “ambiguous column” or “invalid column” errors.
  - Query plan: Right-click query > Display Estimated Execution Plan to check join efficiency.

**Practice (45-60 minutes)**:
- **Activity 1: Write Outer Join Queries**:
  - In your journal, write queries for:
    - All employees with their department names (`LEFT JOIN`).
    - All departments with their employees (`RIGHT JOIN`).
    - All employees and departments (`FULL JOIN`).
  - Example:
    ```sql
    SELECT e.FirstName, e.LastName, d.DepartmentName
    FROM HR.Employees AS e
    LEFT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    ```
- **Activity 2: Run Outer Joins in SSMS**:
  - Use the `EmployeeDB` from Day 12 (`USE EmployeeDB;`). If not available, recreate:
    ```sql
    CREATE DATABASE EmployeeDB;
    USE EmployeeDB;
    CREATE SCHEMA HR;
    CREATE SCHEMA Sales;
    CREATE TABLE HR.Departments (
        DepartmentID INT PRIMARY KEY,
        DepartmentName VARCHAR(50) NOT NULL,
        Location VARCHAR(50)
    );
    INSERT INTO HR.Departments (DepartmentID, DepartmentName, Location)
    VALUES 
        (1, 'IT', 'New York'),
        (2, 'HR', 'Chicago'),
        (3, 'Finance', 'Boston'),
        (4, 'Marketing', 'San Francisco');
    CREATE TABLE HR.Employees (
        EmployeeID INT PRIMARY KEY,
        FirstName VARCHAR(50) NOT NULL,
        LastName VARCHAR(50) NOT NULL,
        Email VARCHAR(100) UNIQUE,
        DepartmentID INT,
        Salary DECIMAL(10,2),
        HireDate DATE DEFAULT GETDATE(),
        CONSTRAINT FK_Employee_Dept FOREIGN KEY (DepartmentID) REFERENCES HR.Departments(DepartmentID)
    );
    INSERT INTO HR.Employees (EmployeeID, FirstName, LastName, Email, DepartmentID, Salary, HireDate)
    VALUES 
        (1, 'Alice', 'Smith', 'alice.smith@company.com', 1, 75000.67, '2023-01-15'),
        (2, 'Bob', 'Johnson', 'bob.johnson@company.com', 2, 65000.33, '2023-02-20'),
        (3, 'Cathy', 'Lee', 'cathy.lee@company.com', 1, 80000.99, '2023-03-10'),
        (4, 'David', 'Wong', 'david.wong@company.com', 3, 70000.45, '2023-04-05'),
        (5, 'Emma', 'Brown', 'emma.brown@company.com', NULL, 60000.12, '2023-05-01');
    CREATE TABLE Sales.Customers (
        CustomerID INT PRIMARY KEY,
        CustomerName VARCHAR(50) NOT NULL,
        Email VARCHAR(100),
        Region VARCHAR(50)
    );
    INSERT INTO Sales.Customers (CustomerID, CustomerName, Email, Region)
    VALUES 
        (1, 'John Doe', 'john.doe@customer.com', 'East'),
        (2, 'Jane Smith', 'jane.smith@customer.com', 'West'),
        (3, 'Mike Brown', 'mike.brown@customer.com', 'North'),
        (4, 'Lisa Green', 'lisa.green@customer.com', 'South');
    CREATE TABLE Sales.Orders (
        OrderID INT PRIMARY KEY,
        CustomerID INT NOT NULL,
        OrderDate DATE NOT NULL,
        TotalAmount DECIMAL(10,2),
        Status VARCHAR(20),
        CONSTRAINT FK_Order_Customer FOREIGN KEY (CustomerID) REFERENCES Sales.Customers(CustomerID)
    );
    INSERT INTO Sales.Orders (OrderID, CustomerID, OrderDate, TotalAmount, Status)
    VALUES 
        (1, 1, '2025-08-01', 199.99, 'Completed'),
        (2, 2, '2025-08-02', 49.99, 'Pending'),
        (3, 1, '2025-08-03', 299.99, 'Completed'),
        (4, 3, '2025-08-04', 99.99, 'Cancelled'),
        (5, 2, '2025-08-05', 149.99, 'Completed');
    ```
  - Run:
    ```sql
    -- LEFT JOIN: All employees, even without departments
    SELECT e.FirstName, e.LastName, d.DepartmentName
    FROM HR.Employees AS e
    LEFT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    -- RIGHT JOIN: All departments, even without employees
    SELECT e.FirstName, e.LastName, d.DepartmentName
    FROM HR.Employees AS e
    RIGHT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    -- FULL JOIN: All employees and departments
    SELECT e.FirstName, e.LastName, d.DepartmentName
    FROM HR.Employees AS e
    FULL JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    ```
  - Verify: Check Results pane for NULLs in unmatched rows (e.g., Emma’s `DepartmentName` is NULL in `LEFT JOIN`).
- **Activity 3: Test with Conditions**:
  - Run:
    ```sql
    SELECT e.FirstName, e.Salary, d.DepartmentName
    FROM HR.Employees AS e
    LEFT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID
    WHERE e.Salary > 70000;
    ```
- **Activity 4: Test Errors**:
  - Try: `SELECT FirstName, DepartmentName FROM HR.Employees LEFT JOIN HR.Departments ON DepartmentID = DepartmentID;` (fails; ambiguous column).
  - Fix: Use `e.DepartmentID = d.DepartmentID`.
  - Try: `SELECT e.FirstName, d.DepartmentName FROM HR.Employees AS e LEFT JOIN HR.Departments AS d ON e.EmployeeID = d.DepartmentID;` (returns incorrect results).
  - Fix: Use correct key columns.

**Resources**:
- Microsoft Docs: “OUTER JOIN (Transact-SQL)” (search “SQL Server LEFT RIGHT FULL JOIN”).
- W3Schools: SQL LEFT, RIGHT, FULL JOIN tutorials.
- SQLZoo: Interactive outer join exercises.

---

#### 2. Handling NULLs (1-1.5 hours)
**Goal**: Manage NULL values in outer join results using functions like `COALESCE` or `ISNULL` to ensure meaningful output.

**Theory (30-45 minutes)**:
- **Why NULLs in Outer Joins?**
  - Outer joins include unmatched rows, resulting in NULLs for columns from the non-matching table.
  - Example: In a `LEFT JOIN` of `Employees` and `Departments`, employees without a department (NULL `DepartmentID`) have NULL `DepartmentName`.
  - NULLs require handling to provide readable or usable results (e.g., replacing NULL with ‘Unassigned’).
- **Handling NULLs**:
  - **COALESCE**: Returns the first non-NULL value from a list of expressions.
    - Syntax: `COALESCE(Expression1, Expression2, ...)`.
    - Example:
      ```sql
      SELECT e.FirstName, COALESCE(d.DepartmentName, 'Unassigned') AS DepartmentName
      FROM HR.Employees AS e
      LEFT JOIN HR.Departments AS d
      ON e.DepartmentID = d.DepartmentID;
      ```
      - Replaces NULL `DepartmentName` with ‘Unassigned’.
  - **ISNULL**: Replaces NULL with a specified value (SQL Server-specific).
    - Syntax: `ISNULL(Expression, ReplacementValue)`.
    - Example:
      ```sql
      SELECT e.FirstName, ISNULL(d.DepartmentName, 'No Department') AS DepartmentName
      FROM HR.Employees AS e
      LEFT JOIN HR.Departments AS d
      ON e.DepartmentID = d.DepartmentID;
      ```
  - **CASE**: Use conditional logic to handle NULLs.
    - Example:
      ```sql
      SELECT e.FirstName, 
             CASE WHEN d.DepartmentName IS NULL THEN 'Unassigned' ELSE d.DepartmentName END AS DepartmentName
      FROM HR.Employees AS e
      LEFT JOIN HR.Departments AS d
      ON e.DepartmentID = d.DepartmentID;
      ```
- **Key Points**:
  - `COALESCE` is ANSI-standard and supports multiple arguments; `ISNULL` is simpler but SQL Server-specific.
  - Use NULL handling in `SELECT` to format output or in `WHERE` to filter results.
  - NULLs affect aggregates (e.g., `SUM` ignores NULLs) and comparisons (e.g., `Column = NULL` is invalid; use `IS NULL`).
- **Best Practices**:
  - Use `COALESCE` or `ISNULL` for readable output in reports.
  - Test queries with and without NULL handling to understand behavior.
  - Combine with `WHERE Column IS NULL` to find unmatched rows.
  - Document NULL handling in your query logic.
- **Common Pitfalls**:
  - Forgetting to handle NULLs leads to confusing outputs.
  - Using `Column = NULL` instead of `Column IS NULL` in `WHERE`.
  - Overcomplicating NULL handling with nested `CASE` when `COALESCE` suffices.
- **SSMS Tools**:
  - View NULLs: Results pane shows NULL for unmatched columns.
  - Filter NULLs: Use `WHERE Column IS NULL` to inspect unmatched rows.
  - Debug errors: Messages pane shows syntax errors in NULL handling.

**Practice (30-45 minutes)**:
- **Activity 1: Write NULL Handling Queries**:
  - In your journal, write queries to:
    - Replace NULL department names with ‘Unassigned’ in a `LEFT JOIN`.
    - Use `ISNULL` to handle NULL customer names in a `RIGHT JOIN`.
    - Use `CASE` to categorize unmatched rows.
  - Example:
    ```sql
    SELECT e.FirstName, COALESCE(d.DepartmentName, 'Unassigned') AS DepartmentName
    FROM HR.Employees AS e
    LEFT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    ```
- **Activity 2: Run NULL Handling in SSMS**:
  - Run:
    ```sql
    -- COALESCE with LEFT JOIN
    SELECT e.FirstName, e.LastName, COALESCE(d.DepartmentName, 'No Department') AS DepartmentName
    FROM HR.Employees AS e
    LEFT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    -- ISNULL with RIGHT JOIN
    SELECT ISNULL(e.FirstName, 'No Employee') AS EmployeeName, d.DepartmentName
    FROM HR.Employees AS e
    RIGHT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    -- CASE with FULL JOIN
    SELECT e.FirstName, 
           CASE WHEN d.DepartmentName IS NULL THEN 'Unassigned' ELSE d.DepartmentName END AS DepartmentName
    FROM HR.Employees AS e
    FULL JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID;
    ```
  - Verify: Check Results pane for replaced NULLs (e.g., Emma’s department as ‘Unassigned’).
- **Activity 3: Filter NULLs**:
  - Run:
    ```sql
    SELECT e.FirstName, e.LastName, d.DepartmentName
    FROM HR.Employees AS e
    LEFT JOIN HR.Departments AS d
    ON e.DepartmentID = d.DepartmentID
    WHERE d.DepartmentName IS NULL;
    ```
    - Finds employees without departments.
- **Activity 4: Test Errors**:
  - Try: `SELECT e.FirstName, d.DepartmentName FROM HR.Employees AS e LEFT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID WHERE d.DepartmentName = NULL;` (fails; invalid comparison).
  - Fix: Use `d.DepartmentName IS NULL`.

---

#### 3. Compare with INNER JOIN (1.5-2 hours)
**Goal**: Understand how `LEFT`, `RIGHT`, and `FULL OUTER JOIN` differ from `INNER JOIN`, and apply outer joins in real-world scenarios with 2-3 tables.

**Theory (30-45 minutes)**:
- **INNER JOIN vs. Outer Joins**:
  - **INNER JOIN**: Returns only rows with matches in both tables.
    - Example: Employees with assigned departments (excludes Emma with NULL `DepartmentID`).
  - **LEFT OUTER JOIN**: Returns all rows from the left table, with NULLs for non-matching rows from the right table.
    - Example: All employees, including those without departments (includes Emma).
  - **RIGHT OUTER JOIN**: Returns all rows from the right table, with NULLs for non-matching rows from the left table.
    - Example: All departments, including those without employees (e.g., Marketing).
  - **FULL OUTER JOIN**: Returns all rows from both tables, with NULLs for non-matching rows.
    - Example: All employees and departments, including unmatched ones.
  - **Comparison Table**:
    | Join Type       | Left Table Rows | Right Table Rows | Unmatched Rows | Use Case Example                     |
    |-----------------|-----------------|------------------|----------------|-------------------------------------|
    | INNER JOIN      | Only matched    | Only matched     | Excluded       | Employees with departments          |
    | LEFT OUTER JOIN | All             | Only matched     | NULLs (right)  | All employees, even unassigned      |
    | RIGHT OUTER JOIN| Only matched    | All              | NULLs (left)   | All departments, even empty         |
    | FULL OUTER JOIN | All             | All              | NULLs (both)   | Complete employee-department report |
- **Key Points**:
  - `INNER JOIN` is more restrictive; outer joins are inclusive.
  - Outer joins are useful for reporting or auditing unmatched data.
  - Combine with `COALESCE`, `ISNULL`, or `CASE` to handle NULLs.
  - Use `WHERE` to filter matched or unmatched rows.
- **Best Practices**:
  - Use `INNER JOIN` when only matched data is needed (e.g., confirmed orders).
  - Use `LEFT JOIN` to prioritize one table’s data (e.g., all customers, even without orders).
  - Rarely use `FULL JOIN` unless both tables’ unmatched rows are needed.
  - Test all join types on the same data to compare results.
- **Common Pitfalls**:
  - Misusing `LEFT` vs. `RIGHT` (e.g., choosing the wrong “base” table).
  - Filtering with `WHERE` that inadvertently excludes NULLs (e.g., `WHERE Column = Value` removes unmatched rows).
  - Performance issues with `FULL JOIN` on large datasets.
- **SSMS Tools**:
  - Compare results: Run `INNER JOIN` and outer joins to see differences.
  - Debug NULLs: Use `WHERE Column IS NULL` to inspect unmatched rows.
  - Execution plan: Compare efficiency of join types.

**Practice (1-1.5 hours)**:
- **Step 1: Set Up Sample Data**:
  - Use `EmployeeDB` with `HR.Employees`, `HR.Departments`, `Sales.Customers`, and `Sales.Orders` (from above).
  - Add a table for products:
    ```sql
    CREATE TABLE Sales.Products (
        ProductID INT PRIMARY KEY,
        ProductName VARCHAR(50) NOT NULL,
        UnitPrice DECIMAL(10,2)
    );
    INSERT INTO Sales.Products (ProductID, ProductName, UnitPrice)
    VALUES 
        (1, 'Laptop', 99.995),
        (2, 'Mouse', 49.99),
        (3, 'Keyboard', 16.663),
        (4, 'Printer', 19.998),
        (5, 'Monitor', 199.99);
    ```
  - Update `Sales.SalesTransactions` to reference `Products`:
    ```sql
    CREATE TABLE Sales.SalesTransactions (
        TransactionID INT PRIMARY KEY,
        OrderID INT,
        ProductID INT,
        Quantity INT NOT NULL,
        UnitPrice DECIMAL(10,2),
        TransactionDate DATE DEFAULT GETDATE(),
        CONSTRAINT FK_Transaction_Order FOREIGN KEY (OrderID) REFERENCES Sales.Orders(OrderID),
        CONSTRAINT FK_Transaction_Product FOREIGN KEY (ProductID) REFERENCES Sales.Products(ProductID)
    );
    INSERT INTO Sales.SalesTransactions (TransactionID, OrderID, ProductID, Quantity, UnitPrice, TransactionDate)
    VALUES 
        (1, 1, 1, 2, 99.995, '2025-08-01'),
        (2, 1, 2, 1, 49.99, '2025-08-01'),
        (3, 2, 3, 3, 16.663, '2025-08-02'),
        (4, 3, 5, 1, 199.99, '2025-08-03'),
        (5, 4, 4, 5, 19.998, '2025-08-04');
    ```
- **Step 2: Write 10-20 Queries for Real Scenarios**:
  - Examples (run each in SSMS and verify):
    1. All employees (LEFT): `SELECT e.FirstName, e.LastName, COALESCE(d.DepartmentName, 'Unassigned') AS DepartmentName FROM HR.Employees AS e LEFT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID;`
    2. All departments (RIGHT): `SELECT ISNULL(e.FirstName, 'No Employee') AS EmployeeName, d.DepartmentName FROM HR.Employees AS e RIGHT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID;`
    3. All employees and departments (FULL): `SELECT e.FirstName, d.DepartmentName FROM HR.Employees AS e FULL JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID;`
    4. All customers (LEFT): `SELECT c.CustomerName, o.OrderID FROM Sales.Customers AS c LEFT JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID;`
    5. All orders (RIGHT): `SELECT c.CustomerName, o.OrderID FROM Sales.Customers AS c RIGHT JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID;`
    6. Compare INNER vs. LEFT: `SELECT c.CustomerName, o.OrderID FROM Sales.Customers AS c INNER JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID; SELECT c.CustomerName, o.OrderID FROM Sales.Customers AS c LEFT JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID;`
    7. Products without transactions (LEFT): `SELECT p.ProductName, t.TransactionID FROM Sales.Products AS p LEFT JOIN Sales.SalesTransactions AS t ON p.ProductID = t.ProductID WHERE t.TransactionID IS NULL;`
    8. High-value orders (LEFT): `SELECT c.CustomerName, o.TotalAmount FROM Sales.Customers AS c LEFT JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID WHERE o.TotalAmount > 100 OR o.TotalAmount IS NULL;`
    9. Transaction details (LEFT): `SELECT o.OrderID, p.ProductName, t.Quantity FROM Sales.Orders AS o LEFT JOIN Sales.SalesTransactions AS t ON o.OrderID = t.OrderID LEFT JOIN Sales.Products AS p ON t.ProductID = p.ProductID;`
    10. Department counts (RIGHT): `SELECT d.DepartmentName, COUNT(e.EmployeeID) AS EmployeeCount FROM HR.Employees AS e RIGHT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID GROUP BY d.DepartmentName;`
    11. Customer orders (FULL): `SELECT c.CustomerName, o.OrderID, o.TotalAmount FROM Sales.Customers AS c FULL JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID;`
    12. Unmatched employees (LEFT): `SELECT e.FirstName, e.LastName, d.DepartmentName FROM HR.Employees AS e LEFT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID WHERE d.DepartmentName IS NULL;`
    13. Unmatched departments (RIGHT): `SELECT e.FirstName, d.DepartmentName FROM HR.Employees AS e RIGHT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID WHERE e.EmployeeID IS NULL;`
    14. Formatted output (LEFT): `SELECT CONCAT(e.FirstName, ' ', e.LastName) AS FullName, COALESCE(d.DepartmentName, 'None') AS Department FROM HR.Employees AS e LEFT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID;`
    15. Transaction totals (LEFT): `SELECT o.OrderID, SUM(t.Quantity * t.UnitPrice) AS TotalValue FROM Sales.Orders AS o LEFT JOIN Sales.SalesTransactions AS t ON o.OrderID = t.OrderID GROUP BY o.OrderID;`
    16. Customer regions (LEFT): `SELECT c.Region, COUNT(o.OrderID) AS OrderCount FROM Sales.Customers AS c LEFT JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID GROUP BY c.Region;`
    17. Product prices (RIGHT): `SELECT p.ProductName, t.Quantity FROM Sales.SalesTransactions AS t RIGHT JOIN Sales.Products AS p ON t.ProductID = p.ProductID;`
    18. Three-table join (LEFT): `SELECT c.CustomerName, o.OrderID, p.ProductName FROM Sales.Customers AS c LEFT JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID LEFT JOIN Sales.SalesTransactions AS t ON o.OrderID = t.OrderID LEFT JOIN Sales.Products AS p ON t.ProductID = p.ProductID;`
    19. Conditional logic (LEFT): `SELECT e.FirstName, d.DepartmentName, CASE WHEN d.DepartmentName IS NULL THEN 'Unassigned' ELSE 'Assigned' END AS Status FROM HR.Employees AS e LEFT JOIN HR.Departments AS d ON e.DepartmentID = d.DepartmentID;`
    20. Error test: `SELECT CustomerName, OrderID FROM Sales.Customers LEFT JOIN Sales.Orders ON CustomerID = CustomerID WHERE OrderID = NULL;` (fails; fix with `OrderID IS NULL`).
- **Step 3: Debug and Validate**:
  - Verify: Check Results pane for matched and unmatched rows (e.g., NULLs for Lisa Green’s orders).
  - Debug errors: Fix ambiguous columns, incorrect `ON` conditions, or invalid NULL comparisons.
  - Compare join types: Run `INNER JOIN` and `LEFT JOIN` on the same tables to see differences.
- **Step 4: Mini-Project**:
  - Create a table `Sales.OrderLogs`:
    ```sql
    CREATE TABLE Sales.OrderLogs (
        LogID INT PRIMARY KEY,
        OrderID INT,
        LogDate DATE,
        LogMessage VARCHAR(100),
        CONSTRAINT FK_Log_Order FOREIGN KEY (OrderID) REFERENCES Sales.Orders(OrderID)
    );
    INSERT INTO Sales.OrderLogs (LogID, OrderID, LogDate, LogMessage)
    VALUES 
        (1, 1, '2025-08-01', 'Order placed'),
        (2, 2, '2025-08-02', 'Awaiting payment'),
        (3, 3, '2025-08-03', 'Order shipped'),
        (4, 5, '2025-08-05', 'Order completed');
    ```
  - Write 5 queries for real scenarios:
    1. All orders with logs (LEFT): `SELECT o.OrderID, o.TotalAmount, COALESCE(l.LogMessage, 'No Log') AS LogMessage FROM Sales.Orders AS o LEFT JOIN Sales.OrderLogs AS l ON o.OrderID = l.OrderID;`
    2. All logs with orders (RIGHT): `SELECT o.OrderID, l.LogMessage FROM Sales.Orders AS o RIGHT JOIN Sales.OrderLogs AS l ON o.OrderID = l.OrderID;`
    3. All orders and logs (FULL): `SELECT o.OrderID, l.LogMessage, l.LogDate FROM Sales.Orders AS o FULL JOIN Sales.OrderLogs AS l ON o.OrderID = l.OrderID;`
    4. Customer orders with logs (LEFT): `SELECT c.CustomerName, o.OrderID, ISNULL(l.LogMessage, 'No Log') AS LogMessage FROM Sales.Customers AS c LEFT JOIN Sales.Orders AS o ON c.CustomerID = o.CustomerID LEFT JOIN Sales.OrderLogs AS l ON o.OrderID = l.OrderID;`
    5. Unmatched logs (RIGHT): `SELECT l.LogID, l.LogMessage, o.OrderID FROM Sales.Orders AS o RIGHT JOIN Sales.OrderLogs AS l ON o.OrderID = l.OrderID WHERE o.OrderID IS NULL;`
- **Step 5: Journal Reflection**:
  - Write answers to:
    - How do outer joins differ from `INNER JOIN`?
    - Why are NULLs common in outer joins, and how can they be handled?
    - When would you use `LEFT` vs. `RIGHT` vs. `FULL JOIN`?
    - Any errors faced and how you resolved them.

**Resources**:
- Microsoft Docs: “Joins (Transact-SQL)” (search “SQL Server OUTER JOIN”).
- W3Schools: SQL LEFT, RIGHT, FULL JOIN tutorials.
- SQLZoo: Interactive outer join exercises.
- YouTube: Search “SQL Server outer joins tutorial” for demos.

---

### Day 13 Deliverables
- **Journal Entries**:
  - Examples of `LEFT`, `RIGHT`, and `FULL OUTER JOIN` queries.
  - Examples of NULL handling with `COALESCE`, `ISNULL`, or `CASE`.
  - Comparison of `INNER JOIN` and outer joins with examples.
  - List of 10-20 queries with real-world scenarios.
  - Notes on errors encountered and solutions.
  - Reflection on the mini-project (e.g., how outer joins enhanced log analysis).
- **Practical Output**:
  - Executed queries with outer joins on `HR.Employees`, `HR.Departments`, `Sales.Customers`, `Sales.Orders`, and `Sales.SalesTransactions`.
  - Created and queried `Sales.OrderLogs` in the mini-project.
  - Validated query results and debugged errors.
- **Self-Assessment**:
  - Can you write `LEFT`, `RIGHT`, and `FULL OUTER JOIN` queries correctly?
  - Can you handle NULLs in outer join results effectively?
  - Can you compare and choose between `INNER JOIN` and outer joins?
  - Can you combine outer joins with other SQL clauses and debug errors?

---

### Tips for Success
- **Practice Extensively**: Run 20+ outer join queries to build fluency.
- **Use SSMS Effectively**: Check Results pane for NULLs and Messages pane for errors.
- **Debug Actively**: Read error messages and search solutions on Microsoft Docs or Stack Overflow.
- **Experiment**: Try different join types and NULL handling methods to understand behavior.
- **Organize Scripts**: Save all queries in a `.sql` file labeled “Day 13 Outer Joins”.
- **Community**: Search “SQL Server outer joins” on X or join a SQL Server forum for tips.

This detailed Day 13 plan ensures you master outer joins, critical for handling unmatched data in MSSQL. If you need help with specific queries, errors, or additional practice scenarios, let me know!
