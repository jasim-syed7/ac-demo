Python Exception Handling: A Detailed Explanation

Exception handling is a crucial concept in Python that allows developers to handle errors and exceptional situations gracefully, preventing program crashes and enabling proper error management.

Table of Contents

1. What are Exceptions?
2. Basic Try-Except Block
3. Handling Specific Exceptions
4. Multiple Except Blocks
5. Else Clause
6. Finally Clause
7. Raising Exceptions
8. Custom Exceptions
9. Exception Hierarchy
10. Best Practices

What are Exceptions?

Exceptions are events that occur during program execution that disrupt the normal flow of instructions. They represent errors or unexpected conditions that need to be handled.

```python
# Common built-in exceptions
# ZeroDivisionError: Division by zero
# ValueError: Invalid value
# TypeError: Wrong data type
# FileNotFoundError: File doesn't exist
# IndexError: List index out of range
# KeyError: Dictionary key doesn't exist
```

Basic Try-Except Block

The fundamental structure for exception handling:

```python
try:
    # Code that might raise an exception
    result = 10 / 0
except:
    # Code to handle the exception
    print("An error occurred!")

# Better practice: catch specific exceptions
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")
```

Handling Specific Exceptions

Always catch specific exceptions rather than using bare except clauses:

```python
try:
    number = int("abc")  # This will raise ValueError
    result = 10 / number
except ValueError:
    print("Invalid number format!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
```

Multiple Except Blocks

You can handle different exceptions with separate blocks:

```python
def process_data(data):
    try:
        # Attempt various operations
        numbers = [int(x) for x in data.split()]
        result = sum(numbers) / len(numbers)
        return result
    except ValueError:
        print("Invalid data format - contains non-numeric values")
    except ZeroDivisionError:
        print("No valid numbers to process")
    except Exception as e:
        print(f"Unexpected error: {e}")

# Test the function
process_data("10 20 abc")  # ValueError
process_data("")           # ZeroDivisionError
```

Else Clause

The else clause runs if no exceptions occur in the try block:

```python
try:
    number = int("42")
    result = 100 / number
except ValueError:
    print("Invalid number!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
else:
    print(f"Calculation successful: {result}")
    # This only runs if no exceptions were raised
```

Finally Clause

The finally clause always executes, regardless of whether an exception occurred:

```python
def read_file(filename):
    file = None
    try:
        file = open(filename, 'r')
        content = file.read()
        return content
    except FileNotFoundError:
        print(f"File {filename} not found!")
        return None
    finally:
        # This always runs - crucial for cleanup
        if file:
            file.close()
        print("Cleanup completed")

# Example usage
content = read_file("nonexistent.txt")
```

Raising Exceptions

You can raise exceptions using the raise keyword:

```python
def validate_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative")
    if age > 150:
        raise ValueError("Age seems unrealistic")
    return True

def calculate_discount(age, amount):
    try:
        validate_age(age)
        if age >= 65:
            return amount * 0.9  # 10% discount
        return amount
    except ValueError as e:
        print(f"Validation error: {e}")
        return amount

# Test the function
print(calculate_discount(25, 100))  # 100
print(calculate_discount(70, 100))  # 90.0
print(calculate_discount(-5, 100))  # Validation error
```

Custom Exceptions

Create your own exception classes for specific error conditions:

```python
class InsufficientFundsError(Exception):
    """Exception raised when there are insufficient funds"""
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        self.message = f"Insufficient funds: ${balance} available, but ${amount} requested"
        super().__init__(self.message)

class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
    
    def withdraw(self, amount):
        if amount > self.balance:
            raise InsufficientFundsError(self.balance, amount)
        self.balance -= amount
        return self.balance

# Usage
account = BankAccount(100)
try:
    account.withdraw(50)
    print(f"Withdrawal successful. Balance: ${account.balance}")
    account.withdraw(100)  # This will raise custom exception
except InsufficientFundsError as e:
    print(e)
```

Exception Hierarchy

Python has a comprehensive exception hierarchy:

```python
# BaseException
#  ├── SystemExit
#  ├── KeyboardInterrupt
#  ├── GeneratorExit
#  └── Exception
#       ├── ArithmeticError
#       │    ├── ZeroDivisionError
#       │    └── FloatingPointError
#       ├── LookupError
#       │    ├── IndexError
#       │    └── KeyError
#       ├── OSError
#       │    ├── FileNotFoundError
#       │    └── PermissionError
#       ├── ValueError
#       ├── TypeError
#       ├── RuntimeError
#       └── ... and many more

def demonstrate_hierarchy():
    try:
        # This will raise a LookupError (parent of IndexError)
        my_list = [1, 2, 3]
        print(my_list[10])
    except LookupError:  # Catches both IndexError and KeyError
        print("A lookup error occurred!")
    except Exception as e:
        print(f"Other error: {e}")

demonstrate_hierarchy()
```

Complete Example: Robust File Processor

```python
import os

class FileProcessor:
    def __init__(self, filename):
        self.filename = filename
    
    def process_file(self):
        try:
            # Check if file exists
            if not os.path.exists(self.filename):
                raise FileNotFoundError(f"File {self.filename} does not exist")
            
            # Open and read file
            with open(self.filename, 'r') as file:
                content = file.read()
            
            # Process content
            lines = content.split('\n')
            numbers = []
            
            for i, line in enumerate(lines, 1):
                try:
                    if line.strip():  # Skip empty lines
                        number = float(line.strip())
                        numbers.append(number)
                except ValueError:
                    print(f"Warning: Line {i} contains invalid data: '{line}'")
            
            if not numbers:
                raise ValueError("No valid numeric data found in file")
            
            # Calculate statistics
            average = sum(numbers) / len(numbers)
            maximum = max(numbers)
            minimum = min(numbers)
            
            return {
                'average': average,
                'max': maximum,
                'min': minimum,
                'count': len(numbers)
            }
            
        except FileNotFoundError as e:
            print(f"File error: {e}")
            return None
        except PermissionError:
            print(f"Permission denied to read {self.filename}")
            return None
        except ValueError as e:
            print(f"Data error: {e}")
            return None
        except Exception as e:
            print(f"Unexpected error: {e}")
            return None
        finally:
            print(f"Finished processing {self.filename}")

# Usage example
processor = FileProcessor("data.txt")
result = processor.process_file()
if result:
    print(f"Results: {result}")
```

Best Practices

1. Be Specific with Exceptions

```python
# Good
try:
    # some code
except ValueError as e:
    handle_error(e)

# Avoid
try:
    # some code
except:
    pass  # This catches ALL exceptions, including SystemExit and KeyboardInterrupt
```

2. Use Finally for Cleanup

```python
def database_operation():
    connection = None
    try:
        connection = connect_to_database()
        # perform operations
        return result
    except DatabaseError as e:
        log_error(e)
        return None
    finally:
        if connection:
            connection.close()  # Always close connection
```

3. Don't Use Exceptions for Control Flow

```python
# Bad - using exceptions for normal flow
try:
    value = my_dict[key]
except KeyError:
    value = default_value

# Good - using get() method
value = my_dict.get(key, default_value)
```

4. Log Exceptions Properly

```python
import logging

logging.basicConfig(level=logging.ERROR)

try:
    risky_operation()
except Exception as e:
    logging.error(f"Operation failed: {e}", exc_info=True)
    # exc_info=True includes stack trace
```

5. Preserve Stack Traces

```python
try:
    complex_operation()
except Exception as e:
    # Add context but preserve original exception
    raise RuntimeError(f"Operation failed: {e}") from e
```

Advanced Exception Handling

Context Managers with Exception Handling

```python
from contextlib import contextmanager

@contextmanager
def managed_resource(*args, **kwds):
    resource = acquire_resource(*args, **kwds)
    try:
        yield resource
    except Exception:
        # Handle exception
        print("Exception occurred in context manager")
        raise
    finally:
        release_resource(resource)

# Usage
with managed_resource() as resource:
    resource.do_something()
```

Exception Groups (Python 3.11+)

```python
# Handling multiple exceptions simultaneously
try:
    raise ExceptionGroup("Multiple errors", [
        ValueError("Invalid value"),
        TypeError("Wrong type"),
        KeyError("Missing key")
    ])
except* ValueError as eg:
    print(f"Value errors: {eg.exceptions}")
except* (TypeError, KeyError) as eg:
    print(f"Type or key errors: {eg.exceptions}")
```

Exception handling is essential for writing robust, production-ready Python code. It allows you to anticipate potential problems, provide meaningful error messages, and ensure your program behaves predictably even when things go wrong.
